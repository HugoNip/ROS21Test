#include <ros/ros.h>
#include <turtlesim/Spawn.h>

int main(int argc, char **argv)
{
	ros::init(argc, argv, "turtle_spawn"); // node name

	ros::NodeHandle node;
	
	/**
	 * Wait for a service to be advertised and available. Blocks until it is.
	 */
	ros::service::waitForService("/spwan"); // service name

	/**
	 * This creates a client for the **"spwan" service**.
	 * The ros::ServiceClient object is used to call the service later on.
	 * 
	 * connect the client to the service of /spawn
	 */
	ros::ServiceClient add_turtle = node.serviceClient<turtlesim::Spawn>("spawn");

	/**
	 * Here we instantiate an autogenerated **service class**, 
	 * and assign values into its request member. 
	 * 
	 * A service class contains two members, request and response. 
	 * It also contains two class definitions, Request and Response.
	 */
	turtlesim::Spawn srv;
	srv.request.x = 2.0;
	srv.request.y = 2.0;
	srv.request.name = "turtle2";

	ROS_INFO("Call service to spwan turtle[x:%0.6f, y:%0.6f, name:%s]",
				srv.request.x, 
				srv.request.y, 
				srv.request.name.c_str());

	/**
	 * This actually **calls the service**.
	 * 
	 * Since service calls are blocking, it will return once the call is done.
	 * 
	 * If the service call succeeded, call() will return true and 
	 * the value in srv.response will be valid.
	 * 
	 * If the call did not succeed, call() will return false and 
	 * the value in srv.response will be invalid.
	 */
	add_turtle.call(srv);

	// get response
	ROS_INFO("Spawn turtle successfully [name: %s]", srv.response.name.c_str());

	return 0;
}